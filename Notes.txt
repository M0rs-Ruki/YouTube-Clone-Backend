
📁 Youtube-Backend-Clone
│
├── 📁 node_modules/             # Auto-generated dependencies (ignored by Git)
├── 📁 public/                   # Public assets
│   └── 📁 temp/                 # Temporary files (e.g. uploads)
│       └── .gitkeep             # Keeps the folder tracked in Git
│
├── 📁 src/                      # Core source folder
│   ├── 📁 controllers/          # Request logic & business operations
│   ├── 📁 db/                   # Database configuration & connection
│       └── 📄 index.js          # Database connection file
│   ├── 📁 middleware/           # Middlewares (auth, error handling, etc.)
│   ├── 📁 models/               # Mongoose schemas/models
│   ├── 📁 routers/              # Express routers
│   └── 📁 utils/                # Utility functions & helpers
│       └── 📄 apiError.js       # Custom API error class
│       └── 📄 asyncHandler.js   # Async error handling middleware
│
│
├── 📄 app.js                    # main server/app file 
├── 📄 constante.js              #  constants file 
├── 📄 index.js                  #  server entry point 
│
├── 📄 .env                      # Environment variables
├── 📄 .gitignore                # Git ignore rules
└── 📄 .prettierignore           # Prettier ignore rules
└── 📄 .prettierrc               # Prettier configuration file
├── 📄 Notes.txt                 # Personal project notes
├── 📄 package-lock.json         # Dependency lock file
├── 📄 package.json              # Project metadata and dependencies
└── 📄 README.md                 # Project overview and instructions

-----------------------------------------------------------------------------

📝 Project Setup Note:
- Ran `npm init` to create `package.json`
- Installed `nodemon` for auto-restarting the server
- Installed `dotenv` for managing environment variables
  
🚀 What is nodemon?
  nodemon is a development tool that automatically restarts your Node.js
  server whenever you make changes to your code.

🛠️ Why use nodemon?
  Without nodemon:
  You have to manually stop and restart your server every time you change a file.
  With nodemon:
  You just save the file, and it auto-restarts the server with the updated code.
  Saves a lot of time during development.

-----------------------------------------------------------------------------------

🛠️ Why use .env?
  The .env file is used to store environment variables—settings 
  or secrets your application needs but that shouldn't be hardcoded
  into your codebase.

-----------------------------------------------------------------------------------

🎨 What is Prettier?
  Prettier is an opinionated code formatter for JavaScript and many other languages.
  It automatically formats your code to look clean, consistent, and readable every
  time you save or run it.

🔧 Why use Prettier?
  ✅ Makes your code consistent across the entire project
  ✅ Removes debates over code style in teams (tabs vs spaces, semicolons, etc.)
  ✅ Saves time on formatting manually
  ✅ Works with most editors (especially VS Code) and integrates with Git and CI tools

🚫 What is .prettierignore?
  .prettierignore is just like .gitignore, but for Prettier.
  It tells Prettier which files or folders it should ignore when formatting.

🧠 Why do we use .prettierignore?
  Because sometimes you don’t want Prettier to touch certain files, like:
  Build folders (dist/, node_modules/)
  Configs or scripts from third parties
  Minified files
  Large JSON files
  Anything you're not actively editing or want to leave untouched

-----------------------------------------------------------------------------------

🚀 Why use Express.js?
  Express is a fast, minimalist web framework for Node.js.
  ✅ Benefits:
  📦 Handles HTTP requests/responses easily
  🛠 Lets you create APIs, routes, and middleware
  🔁 Supports middleware for tasks like logging, validation, and error handling
  ⚡ Very lightweight and flexible
  🧩 Easy to extend with custom logic or third-party packages

-----------------------------------------------------------------------------------

🐍 Why use Mongoose?
  Mongoose is an ODM (Object Data Modeling) library for MongoDB and Node.js.
  ✅ Benefits:
  💾 Helps you define schemas and models for MongoDB collections
  📐 Adds validation, middleware, and query helpers
  🔄 Makes database interaction more structured and readable
  🧠 Reduces direct use of MongoDB's raw query syntax

-----------------------------------------------------------------------------------

🌐 What is the use of CORS?
  CORS stands for Cross-Origin Resource Sharing.
  It is a security feature built into web browsers that controls how web pages 
  from one domain can request data from another domain.

🧠 In simple words:
  Let's say your frontend is running on http://localhost:3000
  And your backend (API) is on http://localhost:5000
  Normally, the browser blocks this because it's two different "origins" (domains + ports)
  CORS allows your backend to say:
  "Hey browser, it's okay — allow requests from localhost:3000."

🛡️ Without CORS:
  🚫 Browser blocks API requests
  🛑 You get errors like "CORS policy error" in the console

-----------------------------------------------------------------------------------

🍪 Why use cookie-parser?
  cookie-parser is a middleware in Express that makes it easy to handle cookies 
  sent by the client (browser).

🧠 In simple words:
  Browsers automatically send cookies (like session tokens, auth tokens)
  along with requests.
  Without cookie-parser, you have to manually extract and parse cookies 
  from request headers 😵‍💫 (which is painful).
  With cookie-parser, it parses cookies for you into a nice JavaScript object. ✨

-----------------------------------------------------------------------------------

🔥 What is the use of middleware in Express?
  Middleware are functions that run in between the incoming request 
  (from client) and the final response (from server).
  Think of middleware like checkpoints — they can modify the request, 
  stop it, or pass it along to the next function.

🧩 Middleware Structure:
  Client Request
      ↓
  [ Middleware 1 ]
      ↓
  [ Middleware 2 ]
      ↓
  [ Route Handler (controller) ]
      ↓
  Server Response

-----------------------------------------------------------------------------------

HTTP response status codes
  1. Informational responses (100-199)
  2. Successful responses (200-299)
  3. Redirection messages (300-399)
  4. Client error responses (400-499)
  5. Server error responses (500-599)