

📁 Youtube-Backend-Clone
│
├── 📁 node_modules/             # Auto-generated dependencies (ignored by Git)
├── 📁 public/                   # Public assets
│   └── 📁 temp/                 # Temporary files (e.g. uploads)
│       └── .gitkeep              # Keeps the folder tracked in Git
│
├── 📁 src/                      # Core source folder
│   ├── 📁 controllers/          # Request logic & business operations
│   ├── 📁 db/                   # Database configuration & connection
│       └── 📄 index.js          # Database connection file
│   ├── 📁 middleware/           # Middlewares (auth, error handling, etc.)
│   ├── 📁 models/               # Mongoose schemas/models
│       └── 📄 user.model.js     # User model file
│       └── 📄 video.model.js    # Video model file
│   ├── 📁 routers/              # Express routers
│   └── 📁 utils/                # Utility functions & helpers
│       └── 📄 apiError.js       # Custom API error class
│       └── 📄 apiResponse.js    # Custom API response class
│       └── 📄 asyncHandler.js   # Async error handling Middleware
│       └── 📄 cloudinary.js     # Handle file uploads in your project.
│
│
├── 📄 app.js                    # main server/app file 
├── 📄 constante.js              #  constants file 
├── 📄 index.js                  #  server entry point 
│
├── 📄 .env                      # Environment variables
├── 📄 .gitignore                # Git ignore rules
└── 📄 .prettierignore           # Prettier ignore rules
└── 📄 .prettierrc               # Prettier configuration file
├── 📄 Notes.txt                 # Personal project notes
├── 📄 package-lock.json         # Dependency lock file
├── 📄 package.json              # Project metadata and dependencies
└── 📄 README.md                 # Project overview and instructions

-----------------------------------------------------------------------------

📝 Project Setup Note:
- Ran `npm init` to create `package.json`
- Installed `nodemon` for auto-restarting the server
- Installed `dotenv` for managing environment variables

-----------------------------------------------------------------------------
  
🚀 What is nodemon?
  nodemon is a development tool that automatically restarts your Node.js
  server whenever you make changes to your code.

🛠️ Why use nodemon?
  Without nodemon:
  You have to manually stop and restart your server every time you change a file.
  With nodemon:
  You just save the file, and it auto-restarts the server with the updated code.
  Saves a lot of time during development.

-----------------------------------------------------------------------------------

🛠️ Why use .env?
  The .env file is used to store environment variables—settings 
  or secrets your application needs but that shouldn't be hardcoded
  into your codebase.

-----------------------------------------------------------------------------------

🎨 What is Prettier?
  Prettier is an opinionated code formatter for JavaScript and many other languages.
  It automatically formats your code to look clean, consistent, and readable every
  time you save or run it.

🔧 Why use Prettier?
  ✅ Makes your code consistent across the entire project
  ✅ Removes debates over code style in teams (tabs vs spaces, semicolons, etc.)
  ✅ Saves time on formatting manually
  ✅ Works with most editors (especially VS Code) and integrates with Git and CI tools

🚫 What is .prettierignore?
  .prettierignore is just like .gitignore, but for Prettier.
  It tells Prettier which files or folders it should ignore when formatting.

🧠 Why do we use .prettierignore?
  Because sometimes you don’t want Prettier to touch certain files, like:
  Build folders (dist/, node_modules/)
  Configs or scripts from third parties
  Minified files
  Large JSON files
  Anything you're not actively editing or want to leave untouched

-----------------------------------------------------------------------------------

🚀 Why use Express.js?
  Express is a fast, minimalist web framework for Node.js.
  ✅ Benefits:
  📦 Handles HTTP requests/responses easily
  🛠 Lets you create APIs, routes, and middleware
  🔁 Supports middleware for tasks like logging, validation, and error handling
  ⚡ Very lightweight and flexible
  🧩 Easy to extend with custom logic or third-party packages

-----------------------------------------------------------------------------------

🐍 Why use Mongoose?
  Mongoose is an ODM (Object Data Modeling) library for MongoDB and Node.js.
  ✅ Benefits:
  💾 Helps you define schemas and models for MongoDB collections
  📐 Adds validation, middleware, and query helpers
  🔄 Makes database interaction more structured and readable
  🧠 Reduces direct use of MongoDB's raw query syntax

-----------------------------------------------------------------------------------

🌐 What is the use of CORS?
  CORS stands for Cross-Origin Resource Sharing.
  It is a security feature built into web browsers that controls how web pages 
  from one domain can request data from another domain.

🧠 In simple words:
  Let's say your frontend is running on http://localhost:3000
  And your backend (API) is on http://localhost:5000
  Normally, the browser blocks this because it's two different "origins" (domains + ports)
  CORS allows your backend to say:
  "Hey browser, it's okay — allow requests from localhost:3000."

🛡️ Without CORS:
  🚫 Browser blocks API requests
  🛑 You get errors like "CORS policy error" in the console

-----------------------------------------------------------------------------------

🍪 Why use cookie-parser?
  cookie-parser is a middleware in Express that makes it easy to handle cookies 
  sent by the client (browser).

🧠 In simple words:
  Browsers automatically send cookies (like session tokens, auth tokens)
  along with requests.
  Without cookie-parser, you have to manually extract and parse cookies 
  from request headers 😵‍💫 (which is painful).
  With cookie-parser, it parses cookies for you into a nice JavaScript object. ✨

-----------------------------------------------------------------------------------

🔥 What is the use of middleware in Express?
  Middleware are functions that run in between the incoming request 
  (from client) and the final response (from server).
  Think of middleware like checkpoints — they can modify the request, 
  stop it, or pass it along to the next function.

🧩 Middleware Structure:
  Client Request
      ↓
  [ Middleware 1 ]
      ↓
  [ Middleware 2 ]
      ↓
  [ Route Handler (controller) ]
      ↓
  Server Response

-----------------------------------------------------------------------------------

🗄️ HTTP response status codes
  1. Informational responses (100-199)
  2. Successful responses (200-299)
  3. Redirection messages (300-399)
  4. Client error responses (400-499)
  5. Server error responses (500-599)

-----------------------------------------------------------------------------------

🧠 What is mongoose-aggregate-paginate-v2?
  ✅ It's a Mongoose plugin.
  ✅ It helps you paginate (split data into pages) when you use aggregation pipelines in MongoDB.

🛠️ Why do we need it?
  Normally, when you do a normal query (.find()), you can paginate easily using .skip() and .limit().
  But when you use complex aggregation pipelines (like $match, $lookup, $group etc.),
  pagination becomes very tricky manually.
  ➡️ That's where mongoose-aggregate-paginate-v2 saves your life!
  It automatically adds skip, limit, total pages, total docs, and more to your aggregation results.

📦 Example Situation Without It:
  Imagine you have millions of videos.
  You want to show only 10 videos per page, sorted by views.
  Normal aggregation will give you ALL videos.
  But you only want page 1, then page 2, and so on.
  ➡️ Without a plugin, you would manually set skip and limit — and it's messy with aggregation.

🏁 Short Summary:
  mongoose-aggregate-paginate-v2 = a plugin to easily paginate big aggregation queries in MongoDB with Mongoose.
  No manual headaches. Cleaner code. Professional backend practice.

-----------------------------------------------------------------------------------

🧠 What is bcrypt?
  ✅ bcrypt is a library used to hash passwords before storing them in a database.
  ✅ It makes passwords super secure so that even if someone hacks your database, 
  they can't see real passwords easily

🛡️ Why do we need bcrypt?
  Storing plain text passwords is VERY dangerous. ❌
  If someone hacks your database, all user passwords would be exposed.
  bcrypt encrypts (hashes) the password into a random-looking string that's impossible to reverse.
  ✅ So even if someone steals your database, they can’t figure out real passwords.

🔥 How bcrypt works in short:
  1. User types a password → e.g., hello123.
  2. Before saving it in the database, you use bcrypt to hash it → something like:
  $2b$10$7Qz2PN9Ujx7T/kA3k0Pb9Op3HJzG9DyM8RjdN9e2PPKXQfAxMeqOa
  3. Later when the user logs in, you don't decrypt —
    Instead, you hash the entered password again and compare the two hashes!

🏁 Very Short Summary:
  bcrypt = tool to hash and compare passwords securely.
  It protects users even if your database is hacked.

-----------------------------------------------------------------------------------

🧠 What is jsonwebtoken (also called JWT)?
  ✅ jsonwebtoken or JWT is a way to create secure tokens for authentication.
  ✅ These tokens are used to prove who the user is without needing to save session data on the server.
In short:
  You log in → server gives you a token (kind of like a passport ✈️).
  You send that token with every request → server trusts you are logged in.

🛡️ Why use jsonwebtoken?
  No need to save user session in server memory = stateless backend = faster.
  Easy for frontend (React, etc.) to store token (usually in cookies or localStorage).
  Super lightweight.
  Used by BIG apps like Facebook, Instagram, YouTube, etc.

🏁 Very Short Summary:
  jsonwebtoken (JWT) is used to create login tokens that securely carry user data.
  It helps build authentication systems that are fast, secure, and scalable.

-----------------------------------------------------------------------------------

